#include <stdio.h>#include <stdlib.h>#include <sys/time.h>#include <math.h>#include <primes.h>#include <general.h>struct item{    int value;    int times;    int *items;};int generate_permutations(int num, int **permutasions_ref);int primes_in_list (int *primes, int num_of_primes, int* list, int list_size, int **primes_list_ref);int list_items_fixed_gap(int *list, int list_size, int num_of_digits, item **result_ref);int num_of_distinct_items(int *list, int num_of_items, int **distinct_items_ref);double result_max(int num1, int num2, int num3);int main(){    int     max_three_digit_num     = 999;    int     max_four_digit_num      = 9999;    int     num_of_permutasions;    int     num_of_primes_in_list;    int     result_size;    int     distinct_items;    int     *lists_primes;    int     *primes;    int     *permutasions;    int     *disnct_items;    item    *result;    int start_index             = sieve_of_eratosthenes(max_three_digit_num, &primes, NULL);    int end_index               = sieve_of_eratosthenes(max_four_digit_num , &primes, NULL);    do {        num_of_permutasions     = generate_permutations(primes[start_index], &permutasions);        num_of_primes_in_list   = primes_in_list(primes, end_index, permutasions, num_of_permutasions, &lists_primes);        result_size             = list_items_fixed_gap(lists_primes, num_of_primes_in_list, 4, &result);        for(int i = 0; i < result_size; i++){            //printf("value: %d,\ttimes: %d, items:", result[i].value, result[i].times);            /**/            //printf("\n");            distinct_items      = num_of_distinct_items(result[i].items, 2*result[i].times, &disnct_items);            //printf("%d\n", distinct_items);            if(distinct_items == 3 && disnct_items[0]/1000 != 0 && disnct_items[1]/1000 != 0 && disnct_items[2]/1000 != 0){                                //printf("solution: %d %d %d\n", disnct_items[0], disnct_items[1], disnct_items[2]);                printf("solution: %f\n", result_max(disnct_items[0], disnct_items[1], disnct_items[2]));                //return 0;            }        }        //printf("%d\n", primes[start_index]);        start_index++;    }while(start_index < end_index);}int primes_in_list (int *primes, int num_of_primes, int* list, int list_size, int **primes_list_ref){    int index           = 0;    int *lists_primes   = (int*)malloc(sizeof(int));    int *tmp_pointer;    for(int i = 0; i < list_size; i++){        for(int j = 0; j < num_of_primes; j++){            if(primes[j] > list[i])                break;            if(primes[j] == list[i]){                tmp_pointer                 = (int*)realloc(lists_primes, ++index*sizeof(int));                lists_primes                = tmp_pointer;                lists_primes[index - 1]     = list[i];            }        }    }    *primes_list_ref    = lists_primes;    return index;}int list_items_fixed_gap(int *list, int list_size, int num_of_digits, item **result_ref){    int     index           = 0;    int     curr_gap_index;    int     tmp_gap;    int     sieve_list_size = power(10, num_of_digits) - 1;    int     *tmp_gap_items_pointer;    int     *tmp_gap_list;    int     *sieve_list     = (int*)calloc(sieve_list_size, sizeof(int));    item    *result_list    = (item*)malloc(sizeof(item));    item    *tmp_list;    item    tmp_item;    int     items_with_gap  = 0;    for(int i = 0; i < list_size; i++){        for(int k = 0; k < list_size; k++){            tmp_gap = list[i] - list[k];            if(tmp_gap > 0){                sieve_list[tmp_gap]++;            }        }    }    for(int i = 0; i < sieve_list_size; i++){        if(items_with_gap < sieve_list[i])            items_with_gap  = sieve_list[i];    }    for(int i = 0; i < sieve_list_size; i++){        if(sieve_list[i] == items_with_gap){            tmp_gap_items_pointer   = (int *)malloc(sizeof(int));            curr_gap_index          = 0;            for(int j = 0; j < list_size; j++){                for(int k = 0; k < list_size; k++){                    tmp_gap = list[j] - list[k];                    if(tmp_gap == i){                        curr_gap_index                              += 2;                        tmp_gap_list                                = (int*) realloc(tmp_gap_items_pointer, curr_gap_index * sizeof(int));                        tmp_gap_items_pointer                       = tmp_gap_list;                        tmp_gap_items_pointer[curr_gap_index - 2]   = list[j];                        tmp_gap_items_pointer[curr_gap_index - 1]   = list[k];                    }                }            }            tmp_item.value          = i;            tmp_item.times          = sieve_list[i];            tmp_item.items          = tmp_gap_items_pointer;            tmp_list                = (item*)realloc(result_list, ++index * sizeof(item));            result_list             = tmp_list;            result_list[index - 1]  = tmp_item;        }    }    *result_ref     = result_list;    return index;}int generate_permutations(int num, int **permutasions_ref){    int curr_num;    int index           = 0;    int *permutasions   = (int*) malloc(sizeof(int));    int *tmp_pointer;    for(int a = 0; a < num_of_digits(num); a++){        for(int b = 0; b < num_of_digits(num); b++){            if(b == a)                continue;            for(int c = 0; c < num_of_digits(num); c++){                if(c == a || c == b)                    continue;                for(int d = 0; d < num_of_digits(num); d++){                    if(d == a || d == b || d == c)                        continue;                    curr_num    = get_digit(num, a)*1000+get_digit(num, b)*100+get_digit(num, c)*10+get_digit(num, d);                    if(!item_in_list(curr_num, permutasions, index)){                        tmp_pointer             = (int*) realloc(permutasions, ++index * sizeof(int));                        permutasions            = tmp_pointer;                        permutasions[index - 1] = curr_num;                    }                }            }        }    }    *permutasions_ref   = permutasions;    return index;}int num_of_distinct_items(int *list, int num_of_items, int **distinct_items_ref){    int index               = 0;    int *distinct_items     = (int *)malloc(sizeof(int));    int *tmp_pointer;    for(int i = 0; i < num_of_items; i++){        if(!item_in_list(list[i], list, i)){            tmp_pointer                 = (int*)realloc(distinct_items, ++index * sizeof(int));            distinct_items              = tmp_pointer;            distinct_items[index - 1]   = list[i];        }    }            *distinct_items_ref = distinct_items;    return index;}double result_max(int num1, int num2, int num3){    double result = 0;    if(num1 > num2){        if(num1 > num3){            if(num2 > num3){                printf("1");                result = (double)num3 * 100000000 + (double)num2 * 10000 + (double)num1;            }else{                printf("2");                result = (double)num2 * 100000000 + (double)num3 * 10000 + (double)num1;            }        }else{            printf("3");            result = (double)num2 * 100000000 + (double)num1 * 10000 + (double)num3;        }    } else {        if(num1 > num3){            printf("4");            result = (double)num2 * 100000000 + (double)num1 * 10000 + (double)num3;        }else{            if(num2 > num3){                printf("5");                result = (double)num2 * 100000000 + (double)num3 * 10000 + (double)num1;            }else{                printf("6");                result = (double)num3 * 100000000 + (double)num2 * 10000 + (double)num1;            }        }    }    return result;}
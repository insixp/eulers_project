#include <stdio.h>#include <stdlib.h>#include <sys/time.h>#include <math.h>#include <primes.h>#include <sort.h>struct item{    int value;    int repetition;};int     consecutive_prime_sum (int max, int *primes, int num_of_primes, item **primes_ref);bool    item_in_sorted_list (int item, int *list, int list_size);int     item_repetition_to_array(item *items_array, int array_list_size, int **result_ref);int     value_of_item(int repetition, item *items_array, int array_list_size);int main(){    //  Constants    int max_num = 1000000;    int     *primes;    int     num_of_primes;    int     *unsorted_array_pointer;    item    *consecutive_primes_item;    int     *consecutive_primes;    int     *ordered_consecutive_primes;    int     num_of_consecutive_primes;    int     num_of_ordered_consecutive_primes;            num_of_primes                       = sieve_of_eratosthenes(max_num, &primes, NULL);    num_of_consecutive_primes           = consecutive_prime_sum(max_num, primes, num_of_primes, &consecutive_primes_item);    printf("Consecutive nums pool:\n");    for(int i = 0; i < num_of_consecutive_primes; i++){        printf("%d, %d\n", consecutive_primes_item[i].value, consecutive_primes_item[i].repetition);    }    num_of_consecutive_primes           = item_repetition_to_array(consecutive_primes_item, num_of_consecutive_primes, &consecutive_primes);    num_of_ordered_consecutive_primes   = merge_sort(consecutive_primes, num_of_consecutive_primes, &ordered_consecutive_primes);            merge_sort_recursive(consecutive_primes, num_of_consecutive_primes, consecutive_primes, num_of_consecutive_primes, &ordered_consecutive_primes);        if(item_in_sorted_list(ordered_consecutive_primes[num_of_ordered_consecutive_primes - 1], consecutive_primes, num_of_consecutive_primes)){        printf("Answer: %d\n", value_of_item(ordered_consecutive_primes[0], consecutive_primes_item, num_of_consecutive_primes));    } else {        printf("not the answer: %d\n", value_of_item(ordered_consecutive_primes[0], consecutive_primes_item, num_of_consecutive_primes));    }    return 0;}int consecutive_prime_sum (int max, int *primes, int num_of_primes, item **primes_ref){    int result_index    = 0;    int curr_index      = 0;    int first_index     = 0;    int real_max        = sqrt(max);    int total_sum;    item *results = (item *)malloc(sizeof(item));    item *tmp_result;    while(primes[first_index] < real_max && first_index < num_of_primes){        curr_index      = first_index++;        total_sum       = primes[curr_index++];        while(total_sum < max){            if(item_in_sorted_list(total_sum, primes, num_of_primes)){                tmp_result                              = (item *) realloc(results, ++result_index * sizeof(item));                results                                 = tmp_result;                results[result_index - 1].value         = total_sum;                results[result_index - 1].repetition    = curr_index - first_index;                            }            total_sum                   += primes[curr_index++];        }        printf("%d\n", primes[first_index]);    }    *primes_ref     = results;    return result_index;}bool item_in_sorted_list (int item, int *list, int list_size){    for(int i = 0; i < list_size; i++){        if(item == list[i])            return true;        if(item < list[i])            break;    }    return false;}int item_repetition_to_array(item *items_array, int array_list_size, int **result_ref){    int *result = (int *)malloc(array_list_size * sizeof(int));        for(int i = 0; i < array_list_size; i++){        result[i]   = items_array[i].repetition;    }        *result_ref     = result;    return array_list_size;}int value_of_item(int repetition, item *items_array, int array_list_size){    for(int i = 0; i < array_list_size; i++){        if(items_array[i].repetition == repetition)            return items_array[i].value;    }    return -1;}